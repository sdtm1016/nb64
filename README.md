# nb64
New Base64 encoding friendly to ASCII characters and Chinese Hanzi.

New base64 主要用于对 英文字符 (utf8 单字节) 和 中文 (utf8 三字节) 字符串编码，使之可以
安全地放置在 URL 中。相比标准 Base64，编码更短。英文字符串，编码后长度约是原串的 7/6。中文字
符串，编码后长度等于原串长度加 2。


### 编码示例
```
英文字符串：We are all good kids. (21)
编码后：   r5UGHklQYdmxAn378iDWpyc1w (25)

中文字符串：我们都是好孩子。 (24)
编码后：   .GIRE7sJD9GYvFl9FtpFtQDAC. (26)

中英文混合：We are all good kids.我们都是好孩子。 (45)
编码后：   r5UGHklQYdmxAn378iDWpyc1w.GIRE7sJD9GYvFl9FtpFtQDAC. (51)

中英文混合：We 我们 are 是 all 都 good 好 kids 孩子.。 (50)
编码后：   r5UA.GIRE7s.QYeWVA.GYv.QYdmxA.JD9.QZ9-_Ig.Fl9.Qa9OTmg.FtpFtQ.XA.DAC. (68)

双字节： ¢ (2)
编码后： .ACi. (5)

四字节： 𐄁 (4)
编码后： .QEB. (5)

混合：  We 我𐄁们 are ¢ 是 all 都 ¢ good 好 kids 孩𐄁子.。(64)
编码后：r5UA.GIRQEBE7s.QYeWVA.ACi.QA.GYv.QYdmxA.JD9.QA.ACi.QZ9-_Ig.Fl9.Qa9OTmg.FtpQEBFtQ.XA.DAC. (88)
```


### 原理

对于所有字符码点都 <=127 的字符串，去掉高位 0 后做 Base64，转成 [A-Za-z0-9-_] 字

符串，末尾不填充；对于所有字符码点都 >127 的字符串，把码点值转成 64进制，并补足三个，也转成
[A-Za-z0-9-_] 字符串，并且在开始和结尾加 '.'。

可以知道，nb64 最大支持编码范围是 [0, 2^18)。



### 算法

先把原始字符按码点大小分割成多个片段，连续的码点  <=127 为一个片段，连续的 >127 也为
一个片段；对于连续的码点 <=127 的片段，所有字符的码点值转成 二进制，然后所有字节去掉高位 0，
然后，6 位一组，前面补两个 0，查表对应成 [A-Za-z0-9-_] 中的某个字母，如果不足6位，末尾添 0；
对于连续的码点 >127 的片段，所有字符的码点值转成 64 进制，并补足三个，也转成
[A-Za-z0-9-_] 字符串，并且在开始和结尾加 '.'。



### UTF8 编码快速处理

对于utf8字符串，码点 >127 字符，因为恰好是 6 位一个分组，所有快速编码算法，对于一个 utf8
编码的字符，除首字节外，后面的字节直接把前两位 10 变成 00即可，对双字节编码的，首字节 110
变成 000，对三字节编码的，首字节 1110 变成 0000，对四字节编码的，直接去掉首字节。

      Unicode符号范围    |        UTF-8编码方式
      (十六进制)         |          （二进制）
    --------------------+---------------------------------------------
    0000 0000-0000 007F | 0xxxxxxx
    0000 0080-0000 07FF | 110xxxxx 10xxxxxx
    0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx
    0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx

### UTF8 字符串编码后长度

| 字符类型 | 码点范围           | 原始长度/x | 编码后长度/y                 | 最坏/R=y/x            | 最好/R                                |
| ---- | -------------- | ------ | ----------------------- | ------------------- | ----------------------------------- |
| 单字节  | [0, 2^7)       | n      | ⌈n*7/6⌉=⌊(n×*7+6)/6⌋    | n=1,x=1,y=2,R=2/1=2 | R=⌊(7n+6)/6⌋/n~=7/6+1/n  n越大越接近 7/6 |
| 双字节  | [2^7 , 2^12 )  | 2n     | 3n+2=(2n)*3/2+2=x*3/2+2 | n=1,x=2,y=5,R=5/2   | R=(3n+2)/2n=3/2+1/n n越大越接近 3/2      |
| 三字节  | [2^12 , 2^17 ) | 3n     | 3n+2=x+2                | n=1,x=3,y=5,R=5/3   | R=(3n+2)/3n=1+2/3n n越大越接近 1         |
| 四字节  | [2^17 , 2^18 ) | 4n     | 3n+2=(4n)*3/4+2=x*3/4+2 | n=1,x=4,y=5,R=5/4   | R=(3n+2)/4n=3/4+1/2n n越大越接近 3/4     |

#### 编码

最环情况下，双字节开头，单、双字节交替出现，然后以双字节结尾，这样编码后最长。即原始
长度 2+1+2+1+2+... 编码后变为 5+2+5+2+5+... 假设双字节有 n 个，那么原始
x = (2n+(n-1))=3n-1，编码后 y = (5n+2(n-1)) = 7n-2 = (3n-1)*7/3+1/3 = x*7/3+1/3，
适合于 x=3n－1(n=1,2,3...) 的情况，其他情况校验一下，见 TestOrder，都符合这个公式，

#### 解码

最坏情况下，所有原始字符都是四字节，这样解码后最长。即 1+3+3+3+...+1，假设四字节
有 n 个，那么编码后 y = 3n+2，原始 x = 4n = (3n+2-2)*4/3 = (y-2)*4/3， 适合于
x=3n－1(n=1,2,3...) 的情况， 其他情况校验一下，见 TestOrder，x<=5  以下有些不符合。
